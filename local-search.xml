<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构（一）——绪论</title>
    <link href="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%BB%AA%E8%AE%BA/"/>
    <url>/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<hr/><h1 id="数据结构在学什么"><a href="#数据结构在学什么" class="headerlink" title="数据结构在学什么"></a>数据结构在学什么</h1><ul><li>如何用程序代码把现实世界的问题信息化</li><li>如何用计算机高效地处理这些信息从而创造价值</li></ul><hr/><h1 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h1><h2 id="什么是数据？"><a href="#什么是数据？" class="headerlink" title="什么是数据？"></a>什么是数据？</h2><p>数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。</p><p>数据是计算机程序加工的原料。</p><h2 id="数据元素、数据项"><a href="#数据元素、数据项" class="headerlink" title="数据元素、数据项"></a>数据元素、数据项</h2><p>数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。</p><p>一个数据元素可由若干个数据项构成，数据项是构成数据元素的不可分割的最小单位。</p><p><em>要根据实际的业务需求来确定什么是数据元素，什么是数据项</em></p><h2 id="数据结构、数据对象"><a href="#数据结构、数据对象" class="headerlink" title="数据结构、数据对象"></a>数据结构、数据对象</h2><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</p><p>数据对象是具有相同性质的数据元素的集合，是数据的一个子集。</p><p>小结一下：<br><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1.JPG"></p><hr/><h1 id="数据结构的三要素"><a href="#数据结构的三要素" class="headerlink" title="数据结构的三要素"></a>数据结构的三要素</h1><p><em>讨论一种数据结构时，要关注的三个方面</em></p><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><ul><li>数据的逻辑结构<ul><li><strong>集合</strong>：各个元素同属一个集合，别无其他关系</li><li><strong>线性结构</strong>：数据结构之间是一对一的关系。除了第一个元素，所有元素都有唯一先驱；除了最后一个元素，所有元素都有唯一后继</li><li><strong>树形结构</strong>：数据元素之间是一对多的关系</li><li><strong>图状结构（网状结构）</strong>：数据元素之间是多对多的关系</li></ul></li></ul><h2 id="物理结构（存储结构）"><a href="#物理结构（存储结构）" class="headerlink" title="物理结构（存储结构）"></a>物理结构（存储结构）</h2><p>如何用计算机表示数据元素的逻辑关系？</p><ul><li>数据的存储结构<ul><li><strong>顺序存储</strong>：把相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现</li><li><strong>链式存储</strong>：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系</li><li><strong>索引存储</strong>：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字、地址）</li><li><strong>散列存储</strong>：根据数据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储</li></ul></li></ul><blockquote><p>数据的存储结构会影响存储空间分配的方便程度。<br>数据的存储结构会影响对数据运算的速度。</p></blockquote><h2 id="数据的运算"><a href="#数据的运算" class="headerlink" title="数据的运算"></a>数据的运算</h2><p>施加在数据上的运算包括运算的定义和实现。<span style="color:red">运算的定义是针对逻辑结构的</span>，指出运算的功能；<span style="color:red">运算的实现是针对存储结构的</span>，指出运算的具体步骤。</p><hr/><h1 id="数据类型、抽象数据类型"><a href="#数据类型、抽象数据类型" class="headerlink" title="数据类型、抽象数据类型"></a>数据类型、抽象数据类型</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型是一个值的集合和定义在此集合上的一组操作的总称。</p><ol><li>原子类型。其值不可再分的数据类型</li><li>结构类型。其值可以再分解为若干成分（分量）的数据类型</li></ol><h2 id="抽象数据类型（Abstract-Data-Type，ADT）"><a href="#抽象数据类型（Abstract-Data-Type，ADT）" class="headerlink" title="抽象数据类型（Abstract Data Type，ADT）"></a>抽象数据类型（Abstract Data Type，ADT）</h2><p>抽象数据类型（Abstract Data Type，ADT）是抽象数据组织及与之相关的操作。<br><em>ADT用数学化的语言定义数据的逻辑结构、定义运算。与具体的实现无关。</em></p><hr/><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h2><p>程序=数据结构+算法</p><ul><li>数据结构：如何用数据正确地描述现实世界的问题，并存入计算机。</li><li>算法：如何高效地处理这些数据，以解决实际问题。</li></ul><p>算法（Algorithm）<strong>是对特定问题求解步骤的一种描述</strong>，它是指令的有限序列，其中的每条指令表示一个或多个操作</p><h2 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h2><ul><li><strong>有穷性</strong>：一个算法必须在执行有穷步之后结束，且每一步都可在有穷时间内完成。</li><li><strong>确定性</strong>：算法中每条指令必须具有确切的含义，对于相同的输入只能得到相同的输出。</li><li><strong>可行性</strong>：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。</li></ul><blockquote><p>输入：一个算法有零个或多个输入，这些输入取自某个特定对象的集合。<br/><br>输出：一个算法有零个或多个输出，这些输出是与输入有着某种特定关系的量。</p></blockquote><h2 id="好的算法应该具备的特质"><a href="#好的算法应该具备的特质" class="headerlink" title="好的算法应该具备的特质"></a>好的算法应该具备的特质</h2><ul><li>正确性：算法能够正确地解决问题。</li><li>可读性：算法应该具有良好的可读性，以帮助人们理解。</li><li>健壮性：输入非法数据时，算法能够适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。</li><li>高效率和低存储需求：时间复杂度低，空间复杂度低</li></ul><hr/><h1 id="算法效率的度量"><a href="#算法效率的度量" class="headerlink" title="算法效率的度量"></a>算法效率的度量</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>事前预估算法时间开销T(n)与问题规模n的关系（T表示“time”）</p><p>计算法则：</p><ol><li>找到一个基本操作</li><li>分析该基本操作的执行次数x与问题规模n的关系x=f(n)</li><li>x的数量级O(x)就是算法的时间复杂度T(n)</li></ol><p>在我们考虑时间复杂度的时候，只需要考虑阶数高的部分。</p><blockquote><p>我们一般使用大O表示法来描述时间复杂度，大O表示“同阶”，同等数量级。即当n趋向于无穷的时候，二者之比为常数。<br><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8ET.JPG"></p></blockquote><h3 id="运算规则"><a href="#运算规则" class="headerlink" title="运算规则"></a>运算规则</h3><ul><li>加法规则：多项相加，只保留最高阶的项，且系数变为1</li><li>乘法规则：多项相乘，都保留<br><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A0%E6%B3%95%E8%A7%84%E5%88%99%E4%B8%8E%E4%B9%98%E6%B3%95%E8%A7%84%E5%88%99.JPG"></li></ul><p><br/><br/></p><blockquote><p>关于更大项的比较，这里有一个要熟稔于心、倒背如流的比较图：<br><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9B%B4%E5%A4%A7%E9%A1%B9%E6%AF%94%E8%BE%83%E5%9B%BE.JPG"><br>助记口令：“常对幂指阶”</p></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>顺序执行的代码只会影响常数项，可以忽略</li><li>只需挑循环中的一个基本操作分析它的执行次数与n的关系即可</li><li>如果有多层嵌套循环，只需关注最深层循环了几次，浅层的循环都是低阶，都将被忽略</li><li>很多算法的执行时间和输入的数据是有关系的，对于这一类的算法我们需要考虑不同情况下的时间复杂度：<ol><li>最坏时间复杂度：最坏情况下算法的时间复杂度</li><li>最好时间复杂度（参考意义不大）：最好情况下算法的时间复杂度</li><li>平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望运行时间</li></ol></li></ol><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><hr/><br/><br/><br/>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>考研</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
