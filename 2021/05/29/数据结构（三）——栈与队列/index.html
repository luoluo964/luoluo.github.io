

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#79bd9a">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>数据结构（三）——栈与队列 - DATASTRUCTURE</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.9-a","typing":{"enable":true,"typeSpeed":60,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>DATA STRUCTURE</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/starNight.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="数据结构（三）——栈与队列">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-05-29 22:09" pubdate>
        2021年5月29日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      46
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">数据结构（三）——栈与队列</h1>
            
            <div class="markdown-body">
              <hr/>

<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><em>线性表是具有相同数据类型的n个数据元素的有限序列</em></p>
<p>栈（Stack）是只允许在一端进行插入或删除操作的线性表（操作受限的线性表）。</p>
<blockquote>
<p>相关术语：</p>
<ul>
<li>栈顶：允许插入和删除的一端</li>
<li>栈底：不允许插入和删除的一端</li>
</ul>
</blockquote>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>特点：后进先出</p>
<h2 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h2><ul>
<li>InitStack(&amp;S)：初始化栈。构成一个空栈S，分配内存空间。</li>
<li>DestroyStack(&amp;L)：销毁栈，销毁并释放栈S所占用的内存空间。</li>
<li>Push(&amp;S,x)：进栈，若栈S未满，则将x加入使之成为新堆栈。</li>
<li>Pop(&amp;S,&amp;x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回。</li>
<li>GetTop(S,&amp;x)：读栈顶元素。若栈非空，则用x返回栈顶元素。</li>
<li>StackEmpty(S)：判断一个栈S是否为空。若S为空，则返回true，否则返回false。</li>
</ul>
<h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><p>卡特兰数公式可以帮助我们快速得出一个栈结构有多少种合法的出栈序列：<br><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0.JPG" srcset="/img/loading.gif" lazyload></p>
<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>用顺序存储方式实现的栈</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="顺序栈的定义"><a href="#顺序栈的定义" class="headerlink" title="顺序栈的定义"></a>顺序栈的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 10  <span class="hljs-comment">//定义栈中元素的最大个数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>	ElemType data[MaxSize];  <span class="hljs-comment">//静态数组存放栈中元素</span><br>	<span class="hljs-keyword">int</span> top;				 <span class="hljs-comment">//栈顶指针</span><br>&#125;SqStack;<br></code></pre></td></tr></table></figure>
<p>栈顶指针一般来说记录的是数组的下标，即一般是从0开始的。</p>
<h4 id="顺序栈的初始化"><a href="#顺序栈的初始化" class="headerlink" title="顺序栈的初始化"></a>顺序栈的初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//初始化栈</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br>	S.top=<span class="hljs-number">-1</span>;	<span class="hljs-comment">//初始化栈顶指针</span><br>&#125;  <br></code></pre></td></tr></table></figure>

<h4 id="判断栈空"><a href="#判断栈空" class="headerlink" title="判断栈空"></a>判断栈空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//判断栈空</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(S.top==<span class="hljs-number">-1</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="新元素入栈"><a href="#新元素入栈" class="headerlink" title="新元素入栈"></a>新元素入栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//新元素入栈</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S,ElemType x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(S.top==MaxSize<span class="hljs-number">-1</span>)  <span class="hljs-comment">//栈满，报错</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	S.data[++S.top]=x;  <span class="hljs-comment">//新元素入栈</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="元素出栈"><a href="#元素出栈" class="headerlink" title="元素出栈"></a>元素出栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//出栈操作</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S,ElemType &amp;x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(S.top==<span class="hljs-number">-1</span>)	<span class="hljs-comment">//栈空，报错</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	x=S.data[S.top--];  <span class="hljs-comment">//栈顶元素先出栈</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="得到栈顶元素"><a href="#得到栈顶元素" class="headerlink" title="得到栈顶元素"></a>得到栈顶元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//读栈顶元素</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack S,ElemType &amp;x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(S.top==<span class="hljs-number">-1</span>)  <span class="hljs-comment">//栈空，报错</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	x=S.data[S.top];  <span class="hljs-comment">//x记录栈顶元素</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>这里我们的设计是让栈顶指针指向了栈的最上面的元素的数组下标（类似于处理器中的SP寄存器——堆栈指针，是时刻指向最上面的元素的），其实往往还有另一种设计思路是让栈顶指针指向最上面的元素的下一个位置，如上的代码就都要有所改动，这里不再赘述。</p>
</blockquote>
<h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><p>为了提高空间利用率，还可以在一个结构体中设计两个指针，一个初始化时指向-1，另一个指向MaxSize，一个从上往下、一个从下往上，判断栈满就判断两个指针是否即将相遇即可。</p>
<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>用链式存储方式实现的栈</p>
<h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span> </span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><br>    ElemType data;   <span class="hljs-comment">//每个结点存放一个数据元素</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//指针指向下一个结点</span><br>&#125;LNode,*LinkList;<br></code></pre></td></tr></table></figure>

<h4 id="初始化（不带头结点）"><a href="#初始化（不带头结点）" class="headerlink" title="初始化（不带头结点）"></a>初始化（不带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//初始化一个空的单链表</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>    L=<span class="hljs-literal">NULL</span>;   <span class="hljs-comment">//空表，暂时还没有任何结点</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="入栈操作（不带头结点）"><a href="#入栈操作（不带头结点）" class="headerlink" title="入栈操作（不带头结点）"></a>入栈操作（不带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(LinkList &amp;L,ElemType e)</span></span>&#123;<br>	LNode *s=(LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br>    <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">NULL</span>) <span class="hljs-comment">//空间分配失败</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>	s-&gt;data=e;<br>    s-&gt;next=L;<br>    L=s;   <br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="出栈（不带头结点）"><a href="#出栈（不带头结点）" class="headerlink" title="出栈（不带头结点）"></a>出栈（不带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//出栈</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Pop</span><span class="hljs-params">(LinkList &amp;L,ElemType &amp;e)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!L) <span class="hljs-comment">//如果栈为空</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	e=L-&gt;data;<br>	L=L-&gt;next;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其他操作并不难，就请读者自行实现。</p>
<hr/>

<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h2><p>队列（Queue）是只允许在一端进行插入，在另一端删除的线性表。</p>
<blockquote>
<p>相关术语：</p>
<ul>
<li>队头：允许插入的一端</li>
<li>队尾：允许删除的一端</li>
<li>空队列：没有元素的队列</li>
</ul>
</blockquote>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>特点：先进先出</p>
<h2 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h2><ul>
<li>InitQueue(&amp;Q)：初始化队列，构造一个空队列Q。</li>
<li>DestroyQueue(&amp;Q)：销毁队列。销毁并释放队列Q所占用的内存空间。</li>
<li>EnQueue(&amp;Q,x)：入队，若队列Q未满，将x加入，使之成为新的队尾。</li>
<li>DeQueue(&amp;Q,&amp;x)：出队，若队列Q非空，删除队头元素，并用x返回。</li>
<li>GetHead(Q,&amp;x)：读队列元素，若队列Q非空，则将队头元素赋值给x。</li>
</ul>
<h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>用顺序存储方式实现的队列。</p>
<h3 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="队列的顺序实现"><a href="#队列的顺序实现" class="headerlink" title="队列的顺序实现"></a>队列的顺序实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//定义队列中元素的最大个数</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 10 </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>	<span class="hljs-comment">//用静态数组存放队列元素</span><br>	ElemType data[MaxSize];<br>	<span class="hljs-comment">//队头指针和队尾指针</span><br>	<span class="hljs-keyword">int</span> front,rear;<br>&#125;SqQueue;<br></code></pre></td></tr></table></figure>

<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span>&#123;<br>	<span class="hljs-comment">//初始时，队头、队尾指针指向0</span><br>	Q.rear=Q.front=<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们的设计中，通常队头指针是指向队头元素；队尾指针则是指向即将添加的位置。</p>
<h4 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">QueueEmpty</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(Q.rear==Q.front)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//入队</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>((Q.rear+<span class="hljs-number">1</span>)%MaxSize==Q.front) <br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//队满时报错</span><br>	Q.data[Q.rear]=x; <span class="hljs-comment">//将x插入队尾</span><br>	Q.rear=(Q.rear+<span class="hljs-number">1</span>)%MaxSize;  <span class="hljs-comment">//队尾指针后移</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们的队列需要利用取余操作使得队尾指针回到前面的内存中，从而确保出队后的前面的空间也可以被很好地利用。</p>
<p><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.JPG" srcset="/img/loading.gif" lazyload></p>
<p>另外，这边相信你也看出来了，我们的牺牲掉了一个空间不存放数据来方便判满，为什么不让front和rear指向一处来判满呢？因为这样就和判空的条件一样了，从而不能正确地实现逻辑。</p>
<blockquote>
<p>如果要求不浪费该存储空间，则可以在顺序队列的定义时附加一个size变量来记录长度，当rear等于front时，size为MaxSize则队满，size为0则队空。</p>
</blockquote>
<blockquote>
<p>又或者可以定义个tag标记变量，每次删除操作成功时，令tag为0,；每次插入操作成功时，令tag为1。当rear等于front，通过tag的最后一次操作即可知道队列是满还是空</p>
</blockquote>
<h4 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//出队（删除一个队头元素，并用x返回）</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(Q.rear==Q.front) <span class="hljs-comment">//判断队空</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//队空则报错</span><br>	x=Q.data[Q.front];<br>	Q.front=(Q.front+<span class="hljs-number">1</span>)%MaxSize; <span class="hljs-comment">//队头指针后移</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="获取队头元素"><a href="#获取队头元素" class="headerlink" title="获取队头元素"></a>获取队头元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetHead</span><span class="hljs-params">(SqQueue Q,ElemType &amp;x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(Q.rear==Q.front)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//队空则报错</span><br>	x=Q.data[Q.front];<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>如果我们想要计算队列中元素的个数：<br>(rear+MaxSize-front)%MaxSize</p>
</blockquote>
<h2 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>用链式存储方式实现的队列。</p>
<h3 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span>&#123;</span> <span class="hljs-comment">//链式队列结点</span><br>	ElemType data;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;LinkNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>  <span class="hljs-comment">//链式队列</span><br>	LinkNode *front,*rear;  <span class="hljs-comment">//队列的队头和队尾指针</span><br>&#125;LinkQueue;<br></code></pre></td></tr></table></figure>

<h4 id="初始化队列（带头结点）"><a href="#初始化队列（带头结点）" class="headerlink" title="初始化队列（带头结点）"></a>初始化队列（带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//初始化队列（带头结点）</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>	<span class="hljs-comment">//初始时，front、rear都指向头结点</span><br>	Q.front=Q.rear=(LinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LinkNode));<br>	Q.front-&gt;next=<span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="判空（带头结点）"><a href="#判空（带头结点）" class="headerlink" title="判空（带头结点）"></a>判空（带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(LinkQueue Q)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(Q.front==Q.rear)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">else</span> <br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="初始化队列（不带头结点）"><a href="#初始化队列（不带头结点）" class="headerlink" title="初始化队列（不带头结点）"></a>初始化队列（不带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//初始化队列（带头结点）</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>	<span class="hljs-comment">//初始时，front、rear都指向NULL</span><br>	Q.front=<span class="hljs-literal">NULL</span>;<br>	Q.rear=<span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="判空（不带头结点）"><a href="#判空（不带头结点）" class="headerlink" title="判空（不带头结点）"></a>判空（不带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(LinkQueue Q)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!Q.front)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">else</span> <br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="入队（带头结点）"><a href="#入队（带头结点）" class="headerlink" title="入队（带头结点）"></a>入队（带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//入队</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;<br>	LinkNode *s=(LinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LinkNode));<br>	s-&gt;data=x;<br>	s-&gt;next=<span class="hljs-literal">NULL</span>;<br>	Q.rear-&gt;next=s;  <span class="hljs-comment">//新结点插入到rear之后</span><br>	Q.rear=s;  <span class="hljs-comment">//修改表尾指针</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><em>这里可以看出，我们的案例中，顺序队列里rear尾指针是指向下一个待插空间的；而链队列里rear尾指针是指向最后一个元素的</em></p>
<h4 id="入队（不带头结点）"><a href="#入队（不带头结点）" class="headerlink" title="入队（不带头结点）"></a>入队（不带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//入队</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;<br>	LinkNode *s=(LinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LinkNode));<br>	s-&gt;data=x;<br>	s-&gt;next=<span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">if</span>(Q.front==<span class="hljs-literal">NULL</span>)&#123;  <span class="hljs-comment">//第一个结点特殊处理</span><br>		Q.front=s;<br>		Q.rear=s;<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		Q.rear-&gt;next=s; <span class="hljs-comment">//新结点插入rear后面</span><br>		Q.rear=s; <span class="hljs-comment">//修改rear结点	</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="出队（带头结点）"><a href="#出队（带头结点）" class="headerlink" title="出队（带头结点）"></a>出队（带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//出队</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(Q.front==Q.rear)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;	<span class="hljs-comment">//空队</span><br>	LinkNode *p=Q.front-&gt;next;<br>	x=p-&gt;data;	<span class="hljs-comment">//用变量x返回队头元素</span><br>	Q.front-&gt;next=p-&gt;next;  <span class="hljs-comment">//修改头结点的next指针</span><br>	<span class="hljs-keyword">if</span>(Q.rear==p)<br>		Q.rear=Q.front;  <span class="hljs-comment">//修改rear指针</span><br>	<span class="hljs-built_in">free</span>(p);  <span class="hljs-comment">//释放结点空间</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;	<br>&#125;<br></code></pre></td></tr></table></figure>
<p><em>front永远指向头结点</em></p>
<h4 id="出队（不带头结点）"><a href="#出队（不带头结点）" class="headerlink" title="出队（不带头结点）"></a>出队（不带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//出队</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(Q.front==<span class="hljs-literal">NULL</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;	<span class="hljs-comment">//空队</span><br>	LinkNode *p=Q.front;<br>	x=p-&gt;data;	<span class="hljs-comment">//用变量x返回队头元素</span><br>	Q.front=p-&gt;next; <br>	<span class="hljs-keyword">if</span>(Q.rear==p)&#123;<br>		Q.rear=<span class="hljs-literal">NULL</span>;<br>		Q.front=<span class="hljs-literal">NULL</span>;<br>	&#125;<br>	<span class="hljs-built_in">free</span>(p);  <span class="hljs-comment">//释放结点空间</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;	<br>&#125;<br></code></pre></td></tr></table></figure>

<hr/>

<h1 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h1><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>只允许从两端插入、两端删除的线性表</p>
<blockquote>
<p>延伸出更多的变种：</p>
<ul>
<li>输入受限的双端队列：只允许从一端插入、两端删除的线性表。</li>
<li>输出受限的双端队列：只允许从两端插入、一端删除的线性表。</li>
</ul>
</blockquote>
<p><em>关于这种问题只要知道哪种输出顺序是可能实现的即可，这里不再赘述</em></p>
<h2 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h2><h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><p>分析一串字符串中的“()”、“[]”、“{}”是否成双出现。</p>
<blockquote>
<p>我们通过分析可以发现两个括号分析的特点：</p>
<ol>
<li>最后出现的左括号最先被匹配</li>
<li>每出现一个右括号，就“消耗”一个左括号</li>
</ol>
</blockquote>
<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.JPG" srcset="/img/loading.gif" lazyload></p>
<h3 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bracketCheck</span><span class="hljs-params">(<span class="hljs-keyword">char</span> str[],<span class="hljs-keyword">int</span> length)</span></span>&#123;<br>	SqStack S;<br>	<span class="hljs-built_in">InitStack</span>(S);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)&#123;<br>		<span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;(&#x27;</span>||str[i]==<span class="hljs-string">&#x27;[&#x27;</span>||str[i]==<span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>			<span class="hljs-built_in">Push</span>(S,str[i]);  <span class="hljs-comment">//扫描到左括号，入栈</span><br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;)&#x27;</span>||str[i]==<span class="hljs-string">&#x27;]&#x27;</span>||str[i]==<span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;<br>				<span class="hljs-keyword">if</span>(<span class="hljs-built_in">StackEmpty</span>(S))  <span class="hljs-comment">//扫描到右括号，且当前栈空</span><br>					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>				ElemType topElem;<br>				<span class="hljs-built_in">Pop</span>(S,topElem);  <span class="hljs-comment">//栈顶元素出栈</span><br>				<span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;)&#x27;</span>&amp;&amp;topElem!=<span class="hljs-string">&#x27;(&#x27;</span>)<br>					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>				<span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;]&#x27;</span>&amp;&amp;topElem!=<span class="hljs-string">&#x27;[&#x27;</span>)<br>					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>				<span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;&#125;&#x27;</span>&amp;&amp;topElem!=<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;			<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h2><h3 id="三种算术表达式"><a href="#三种算术表达式" class="headerlink" title="三种算术表达式"></a>三种算术表达式</h3><p><em>表达式：表达算术运算的式子，往往由三个部分组成：操作数、运算符、界限符</em></p>
<ul>
<li>中缀表达式：即普通的表达式。运算符在两个操作数的中间。中缀表达式中界限符（即括号）是必要的，表明了计算优先顺序。</li>
<li>后缀表达式：又称逆波兰表达式。运算符在两个操作数的后面。</li>
<li>前缀表达式：又称波兰表达式。运算符在两个操作数的前面。</li>
</ul>
<h3 id="逆波兰表达式-波兰表达式换算"><a href="#逆波兰表达式-波兰表达式换算" class="headerlink" title="逆波兰表达式/波兰表达式换算"></a>逆波兰表达式/波兰表达式换算</h3><p>以逆波兰表达式为例，将当前运算中的运算符移至右边，如此往复:</p>
<ol>
<li>确定中缀表达式中各个运算符的运算顺序</li>
<li>选择下一个运算符，按照[左操作数 右操作数 运算符]的方式组合成一个新的操作数</li>
<li>如果还有运算符没有被处理，则重复2</li>
</ol>
<p><em>如：a+b-c*d  –&gt; ab+cd*-</em> </p>
<p><strong>注意：严格意义上后缀表达式并不唯一，如下图所示，为了确保算法的“唯一性”，我们默认转换表达式时，只要左边的运算符能被先运算，就优先从左运算（左优先原则），如果是前缀表达式，则遵循右优先原则</strong></p>
<p><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%89%E7%A7%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%94%AF%E4%B8%80.JPG" srcset="/img/loading.gif" lazyload></p>
<h3 id="后缀表达式运算（用栈实现）"><a href="#后缀表达式运算（用栈实现）" class="headerlink" title="后缀表达式运算（用栈实现）"></a>后缀表达式运算（用栈实现）</h3><ol>
<li>将数1加入栈</li>
<li>将数2加入栈</li>
<li>遇到符号，将数1、数2取出和符号运算，然后将运算结果放入栈作新的数1</li>
<li>如此往复</li>
</ol>
<p><em>计算机更适合用后缀表达式去计算，故很多基于栈的编程语言：Forth、PostScribe都是用后缀表达式来运算的</em></p>
<h3 id="中缀表达式转后缀表达式（用栈实现）"><a href="#中缀表达式转后缀表达式（用栈实现）" class="headerlink" title="中缀表达式转后缀表达式（用栈实现）"></a>中缀表达式转后缀表达式（用栈实现）</h3><p>主要思路：</p>
<ol>
<li>初始化一个栈，用于保存暂时还不确定运算顺序的运算符。</li>
<li>从左到右处理各个元素，直到末尾。可能遇到三种情况：<ol>
<li>遇到<strong>操作数</strong>，直接加入后缀表达式。</li>
<li>遇到<strong>界限符</strong>，遇到“(”直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，知道弹出“(”为止。注意：“(”不加入后缀表达式。</li>
<li>遇到<strong>运算符</strong>。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式。若碰到“(”或栈空则停止。之后再把当前运算符入栈。</li>
</ol>
</li>
<li>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</li>
</ol>
<h3 id="中缀表达式的计算（用栈实现）"><a href="#中缀表达式的计算（用栈实现）" class="headerlink" title="中缀表达式的计算（用栈实现）"></a>中缀表达式的计算（用栈实现）</h3><p><em>前面我们了解过利用栈来进行后缀表达式的计算，可以发现很简单，也正因如此说计算机更适合用后缀表达式运算，现在我们来了解一下用中缀表达式计算，其实也就是上面两个算法的集合。</em><br><br/><br/></p>
<ol>
<li>初始化两个栈，操作数栈和运算符栈。</li>
<li>若扫描到操作数，压入操作数栈。</li>
<li>若扫描到运算符或者界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，每弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈） </li>
<li>扫描完成后，弹出运算符栈的所有运算符，每弹出一个，就弹出两个操作数进行运算。</li>
</ol>
<h2 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h2><h3 id="函数调用的背后"><a href="#函数调用的背后" class="headerlink" title="函数调用的背后"></a>函数调用的背后</h3><p>函数调用时，需要一个栈存储：</p>
<ol>
<li>调用返回地址：函数执行完成后返回的地址，即调用函数的那条语句的下一条语句的地址。当程序返回后，调用函数的语句的下一条语句就会被执行（地址被赋给CS、IP寄存器，即将被CPU执行）</li>
<li>实参：调用函数传来的参数，这两个参数放在栈中被临时保存，这也就是为什么一般传参是“值传递”，因为子函数下的参数是栈中的“临时数据”</li>
<li>局部变量：子函数中定义的局部变量，在子函数执行完成后会被回收。</li>
</ol>
<blockquote>
<p>递归调用时，函数调用栈可称为“递归工作栈”</p>
<ul>
<li>每进入一层递归，就将递归调用所需信息压入栈顶</li>
<li>每退出一层递归，就从栈顶弹出相应信息</li>
</ul>
</blockquote>
<h3 id="栈在递归中的应用"><a href="#栈在递归中的应用" class="headerlink" title="栈在递归中的应用"></a>栈在递归中的应用</h3><p>适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题。</p>
<p><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E6%A0%88-%E6%B1%82%E9%98%B6%E4%B9%98.JPG" srcset="/img/loading.gif" lazyload></p>
<p><strong>递归缺点：太多层递归可能会导致栈溢出</strong></p>
<p><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E6%A0%88-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.JPG" srcset="/img/loading.gif" lazyload></p>
<p><strong>递归缺点：递归可能会包含很多重复计算</strong></p>
<hr/>
<hr/>
<hr/>











            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%80%83%E7%A0%94/">考研</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    商业转载 请联系作者获得授权，非商业转载 请标明出处，谢谢
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/">
                        <span class="hidden-mobile">数据结构（二）——线性表</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://is-hash.com" target="_blank" rel="nofollow noopener"><span>关于我的更多</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/luoluo964/luoluo.github.io.git" target="_blank" rel="nofollow noopener"><span>本网站的github</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
